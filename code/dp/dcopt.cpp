// Divide and Conquer DP Optimization - O(k*n^2) => O(k*n*logn) FROM IME
//
// dp[i][j] = min k<i { dp[k][j-1] + C[k][i] }
//
// Condition: A[i][j] <= A[i+1][j]
// A[i][j] is the smallest k that gives an optimal answer to dp[i][j]
int n, maxj;
int dp[MAXN][MAXM], a[MAXN][MAXM];

// declare the cost function
int cost( int i, int j ) {
	// ...
}

void calc( int l, int r, int j, int kmin, int kmax ) {
	int m = ( l + r )/2;
	dp[m][j] = LINF;
	for( int k = kmin; k <= kmax; ++k ) {
		ll v = dp[k][j-1] + cost( k, m );
		// store the minimum answer for d[m][j]
		// in case of maximum, use v > dp[m][j]
		if( v < dp[m][j] ) a[m][j] = k, dp[m][j] = v;
	}

	if( l < r ) {
		calc( l, m, j, kmin, a[m][k] );
		calc( m + 1, r, j, a[m][k], kmax );
	}
}

// run for every j
for( int j = 2; j <= maxj; ++j )
	calc( 1, n, j, 1, n );
